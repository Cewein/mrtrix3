#!/usr/bin/env python

import argparse
import math
import numpy as np
from scipy.linalg import logm, expm


def getsliceorder(n, p=2, s=1):
    return np.array([j for k in range(0,p) for j in range((k*s)%p,n,p)], dtype=int)


def tr2lie(T):
    r = np.zeros((6,))
    try:
        L = logm(T)
        R = 0.5 * (L - L.T)
        r[:3] = L[:3,3]
        r[3:] = R[2,1], R[0,2], R[1,0]
    except:
        pass
    return r


def lie2tr(r):
    L = np.zeros((4,4))
    L[:3,3] = r[:3]
    L[2,1] = r[3] ; L[1,2] = -r[3]
    L[0,2] = r[4] ; L[2,0] = -r[4]
    L[1,0] = r[5] ; L[0,1] = -r[5]
    T = expm(L)
    return T


def tr2euler(T):
    sy = math.hypot(T[0,0], T[1,0])
    if sy > 1e-6:
        roll = math.atan2(T[2,1], T[2,2])
        pitch = math.atan2(-T[2,0], sy)
        yaw = math.atan2(T[1,0], T[0,0])
    else:
        roll = math.atan2(-T[1,2], T[1,1])
        pitch = math.atan2(-T[2,0], sy)
        yaw = 0.0
    return np.array([T[0,3], T[1,3], T[2,3], yaw, pitch, roll])



if __name__ == '__main__':
    # arguments
    parser = argparse.ArgumentParser(description='Filtering a series of rigid motion parameters.')
    parser.add_argument('input', type=str, help='input motion file')
    parser.add_argument('weights', type=str, help='input weight matrix')
    parser.add_argument('output', type=str, help='output motion file')
    #parser.add_argument('-mb', type=int, default=1, help='multiband factor')
    parser.add_argument('-packs', type=int, default=2, help='no. slice packs')
    parser.add_argument('-shift', type=int, default=1, help='slice shift')
    # mandatory MRtrix options (unused)
    parser.add_argument('-nthreads', type=int, default=1, help='no. threads (unused)')
    parser.add_argument('-info', help='(unused)')
    parser.add_argument('-debug', help='(unused)')
    parser.add_argument('-quiet', help='(unused)')
    parser.add_argument('-force', help='(unused)')
    args = parser.parse_args()
    # read inputs
    M = np.loadtxt(args.input)
    W = np.loadtxt(args.weights)
    # set up slice order
    nv = W.shape[1]
    ne = M.shape[0]//nv
    sliceorder = getsliceorder(ne, args.packs, args.shift)
    isliceorder = np.argsort(sliceorder)
    # reorder
    M1 = np.reshape(M.reshape((nv,ne,6))[:,sliceorder,:], (-1,6))
    W1 = np.reshape(np.mean(W.reshape((-1, ne, nv)), axis=0)[sliceorder,:], (-1,1))
    # filter: t'_i = w * t_i + (1-w) * (t'_(i-1) + t'_(i+1)) / 2
    A = np.eye(nv*ne) - 0.5 * (1.-W1) * (np.eye(nv*ne, k=1) + np.eye(nv*ne, k=-1))
    A[0,1] = W1[0] - 1
    A[-1,-2] = W1[-1] - 1
    M2 = np.linalg.solve(A, W1 * M1)
    # reorder outtput
    M3 = np.reshape(M2.reshape((nv,ne,6))[:,isliceorder,:], (-1,6))
    np.savetxt(args.output, M3, fmt='%.6f')


