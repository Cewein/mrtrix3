#!/usr/bin/env python

#   MOTION CORRECTION FOR DWI VOLUME SERIES
#
#   This script performs volume-to-series and slice-to-series registration
#   of diffusion-weighted images for motion correction in the brain.
#
#   Author:  Daan Christiaens
#            King's College London
#            daan.christiaens@kcl.ac.uk
#

#   __________ Initialisation __________

# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys, subprocess
p = subprocess.Popen(['which', 'mrinfo'], stdout=subprocess.PIPE)
line = p.stdout.readline().decode().strip()
lib_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(line)[0], os.pardir, 'lib')))
if not os.path.isdir(lib_folder):
    sys.stderr.write('Unable to locate MRtrix3 Python libraries')
    sys.exit(1)
sys.path.insert(0, lib_folder)
from mrtrix3 import app, fsl, image, path, run


app.init('Daan Christiaens (daan.christiaens@kcl.ac.uk)',
         'Perform motion correction for a DWI volume series')

app.cmdline.add_argument('input',  help='The input image series to be corrected')
app.cmdline.add_argument('output', help='The output multi-shell SH coefficients')

options = app.cmdline.add_argument_group('Options for the dwimotioncorrect script')
options.add_argument('-mask', help='Manually provide a mask image for motion correction')
options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
options.add_argument('-niter', help='Number of epochs (default = 3)')
#options.add_argument('-shells', help='Shells to be processed (default = all)')
options.add_argument('-lmax', help='SH basis order per shell (default = 0,4,4,...)')
options.add_argument('-rlmax', help='Reduced basis order per component for registration (default = 2,2,0)')
options.add_argument('-reg', help='Regularization for dwirecon (default = 0.01)')
#options.add_argument('-rf', help='Basis functions for the radial domain')
options.add_argument('-svr', help='Number of slice-to-volume reconstruction epochs (default = 0)')
options.add_argument('-mb', help='Multiband factor (default = 1)')
#options.add_argument('-sorder', help='Slice order (default = 2,1, for odd-even)')
options.add_argument('-sspwidth', help='Slice thickness for Gaussian SSP (default = 1)')
options.add_argument('-sspfile', help='Slice sensitivity profile as vector')
options.add_argument('-or_loss', help='Outlier rejection loss function (default = softl1)')
options.add_argument('-fieldmap', help='B0 field map for distortion correction')
options.add_argument('-fieldidx', help='Index of volume to which field map is aligned (default = 0)')
options.add_argument('-pe_table', help='Phase encoding table in MRtrix format')
options.add_argument('-pe_eddy', nargs=2, help='Phase encoding table in FSL acqp/index format')
options.add_argument('-export_motion', help='Export rigid motion parameters')
options.add_argument('-export_weights', help='Export slice weights')
app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )
app.parse()


grad_import_option = ''
if app.args.grad:
    grad_import_option = ' -grad ' + path.fromUser(app.args.grad, True)
elif app.args.fslgrad:
    grad_import_option = ' -fslgrad ' + path.fromUser(app.args.fslgrad[0], True) + ' ' + path.fromUser(app.args.fslgrad[1], True)

pe_import_option = ''
if app.args.pe_table:
    pe_import_option = ' -import_pe_table ' + path.fromUser(app.args.pe_table, True)
elif app.args.pe_eddy:
    pe_import_option = ' -import_pe_eddy ' + path.fromUser(app.args.pe_eddy[0], True) + ' ' + path.fromUser(app.args.pe_eddy[1], True)


app.checkOutputPath(app.args.output)
if app.args.export_motion:
    app.checkOutputPath(app.args.export_motion)
if app.args.export_weights:
    app.checkOutputPath(app.args.export_weights)


app.makeTempDir()

run.command('mrconvert ' + path.fromUser(app.args.input, True) + ' ' + path.toTemp('in.mif', True) + grad_import_option + pe_import_option)
if app.args.mask:
    run.command('mrconvert ' + path.fromUser(app.args.mask, True) + ' ' + path.toTemp('mask.mif', True))
if app.args.fieldmap:
    run.command('mrconvert ' + path.fromUser(app.args.fieldmap, True) + ' ' + path.toTemp('field.mif', True))

app.gotoTempDir()


# Make sure it's actually a DWI that's been passed
dwi_sizes = image.headerField('in.mif', 'size').split()
if len(dwi_sizes) != 4:
    app.error('Input image must be a 4D image')
DW_scheme = image.headerField('in.mif', 'dwgrad').split('\n')
if len(DW_scheme) != int(dwi_sizes[3]):
    app.error('Input image does not contain valid DW gradient scheme')

# Check PE table if field map is passed.
if app.args.fieldmap:
    PE_scheme = image.headerField('in.mif', 'petable').split('\n')
    if len(PE_scheme) != int(dwi_sizes[3]):
        app.error('Input image does not contain valid phase encoding scheme')


# Generate a brain mask if required, or check the mask if provided
if app.args.mask:
    mask_sizes = image.headerField('mask.mif', 'size').split()
    if not mask_sizes[:3] == dwi_sizes[:3]:
        app.error('Provided mask image does not match input DWI')
else:
    run.command('dwi2mask in.mif mask.mif')


# Set no. iterations
v2viter = 3
if app.args.niter:
    v2viter = int(app.args.niter)
s2viter = 0
if app.args.svr:
    s2viter = int(app.args.svr)
niter = v2viter + s2viter

# Select shells
shells = [s.split('.')[0] for s in image.headerField('in.mif', 'shells').split()]
#if app.args.shells:
#    shells = app.args.shells.split(',')

# Set lmax
lmax = [4,]*len(shells)
lmax[0] = 0
if app.args.lmax:
    lmax = [int(l) for l in app.args.lmax.split(',')]
if len(lmax) != len(shells):
    app.error('No. lmax must match no. shells.')

rlmax = [2,2,0]
if app.args.rlmax:
    rlmax = [int(l) for l in app.args.rlmax.split(',')]
if len(rlmax) > len(lmax) or max(rlmax) > max(lmax):
    app.error('-rlmax invalid.')


# Shared reconstruction options
recon_option = '-maxiter 3'
if app.args.reg:
    recon_option += ' -reg ' + app.args.reg
#if app.args.fieldmap:
#    recon_option += ' -field field1.mif'

# SSP option
ssp_option = ''
if app.args.sspfile:
    run.command('cp ' + path.fromUser(app.args.sspfile, True) + ' ssp.txt')
    ssp_option = ' -ssp ssp.txt'
elif app.args.sspwidth:
    ssp_option = ' -ssp ' + app.args.sspwidth


# Initialise radial basis with RF per shell.
rfs = []
for k, l in enumerate(lmax):
    fn = 'rf'+str(k+1)+'.txt'
    with open(fn, 'w') as f:
        for s in range(len(shells)):
            if k==s:
                f.write(' '.join(['1',]*(l//2+1)) + '\n')
            else:
                f.write(' '.join(['0',]*(l//2+1)) + '\n')
    rfs += [fn,]

redrfs = ['redrf'+str(k+1)+'.txt' for k in range(len(rlmax))]

# Force max no. threads
if app.args.nthreads:
    nthr = ' -nthreads ' + app.args.nthreads
else:
    nthr = ''

# Set multiband factor
mb = 1
if app.args.mb:
    mb = int(app.args.mb)

# Set OR loss
or_option = ' -mb ' + str(mb)
if app.args.or_loss:
    or_option += ' -loss ' + app.args.or_loss

# Slice order
#motfilt_option = ' -extent 1'
#if mb > 1:
#    motfilt_option += ' -mb ' + str(mb)
#if app.args.sorder:
#    p,s = app.args.sorder.split(',')
#    motfilt_option += ' -packs ' + p + ' -shift ' + s


# Image dimensions
dims = list(map(int, image.headerField('in.mif', 'size').split()))
vox = list(map(float, image.headerField('in.mif', 'vox').split()))
vu = (vox[0]+vox[1])/2.

# Shell weights
with open('svdweights.txt', 'w') as f:
    f.write(image.headerField('in.mif', 'shellcount') + '\n')


#   __________ Function definitions __________

def reconstep(k):
    run.command('dwirecon in1.mif recon-' + str(k) + '.mif -spred spred.mif ' + recon_option + ssp_option + ' -rf ' + ' -rf '.join(rfs) +
            ('' if k==0 else ' -motion motion.txt -weights sliceweights.txt -init recon-' + str(k-1) + '.mif') + ' -force' + nthr)


def sliceweightstep():
    run.command('dwisliceoutliers in1.mif spred.mif -mask mask.mif sliceweights.txt' + or_option + ' -force')


def basisupdatestep(k):
    run.command('msshsvd recon-' + str(k) + '.mif -mask mask.mif -lmax ' + ','.join([str(l) for l in sorted(lmax)[::-1]]) +
                ' -weights svdweights.txt ' + ' '.join(rfs) + ' -force')


def rankreduxstep(k):
    run.command('msshsvd recon-' + str(k) + '.mif -mask mask.mif -lmax ' + ','.join([str(l) for l in rlmax]) +
                ' -weights svdweights.txt ' + ' '.join(redrfs) + ' -proj irankredux.mif -force')
    scale = 4. - 3.*k / (v2viter-1) if k < v2viter else 2. - 1.*(k-v2viter) / (s2viter-1)
    run.command('mrfilter irankredux.mif smooth rankredux.mif -fwhm ' + str(scale*vu) + ' -force')


def registrationstep(k):
    run.command('dwislicealign in1.mif rankredux.mif motion.txt -mask mask.mif -maxiter 3' +
                ' -mb ' + ('0' if k<v2viter else str(mb)) + (' -init motion.txt' if k>0 else '') +
                ssp_option + ' -force' + nthr)


def fieldalignstep(k):
    if app.args.fieldmap:
        if k == 0:
            run.command('mrfieldunwarp in.mif field.mif in1.mif')
        else:
            fidx = '-fidx ' + ('0' if not app.args.fieldidx else app.args.fieldidx)
            run.command('mrfieldunwarp in.mif field.mif -motion motion.txt ' + fidx + ' in1.mif -force')
    else:
        if k == 0:
            run.command('mrconvert in.mif in1.mif')



#   __________ Motion correction __________

# initial template
fieldalignstep(0)
reconstep(0)

# running reconstruction
for k in range(v2viter + s2viter):
    sliceweightstep()
    basisupdatestep(k)
    # register template to volumes
    rankreduxstep(k)
    registrationstep(k)
    fieldalignstep(k+1)
    # update template
    reconstep(k+1)


#   __________ Copy outputs __________

run.command('mrconvert recon-'+str(v2viter+s2viter)+'.mif ' + path.fromUser(app.args.output, True) + (' -force' if app.force else ''))

if app.args.export_motion:
    run.command('cp motion.txt ' + path.fromUser(app.args.export_motion, True))

if app.args.export_weights:
    run.command('cp sliceweights.txt ' + path.fromUser(app.args.export_weights, True))


app.complete()




