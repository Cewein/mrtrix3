#!/usr/bin/env python

#   MOTION CORRECTION FOR DWI VOLUME SERIES
#
#   This script performs volume-to-series and slice-to-series registration
#   of diffusion-weighted images for motion correction in the brain.
#
#   Author:  Daan Christiaens
#            King's College London
#            daan.christiaens@kcl.ac.uk
#

#   __________ Initialisation __________

# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys, subprocess
p = subprocess.Popen(['which', 'mrinfo'], stdout=subprocess.PIPE)
line = p.stdout.readline().decode().strip()
lib_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(line)[0], os.pardir, 'lib')))
if not os.path.isdir(lib_folder):
    sys.stderr.write('Unable to locate MRtrix3 Python libraries')
    sys.exit(1)
sys.path.insert(0, lib_folder)
from mrtrix3 import app, fsl, image, path, run


app.init('Daan Christiaens (daan.christiaens@kcl.ac.uk)',
         'Perform motion correction for a DWI volume series')

app.cmdline.add_argument('input',  help='The input image series to be corrected')
app.cmdline.add_argument('output', help='The output multi-shell SH coefficients')

options = app.cmdline.add_argument_group('Options for the dwimotioncorrect script')
options.add_argument('-mask', help='Manually provide a mask image for motion correction')
options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
options.add_argument('-niter', help='Number of epochs (default = 3)')
#options.add_argument('-shells', help='Shells to be processed (default = all)')
options.add_argument('-lmax', help='SH basis order per shell (default = 0,4,4,...)')
options.add_argument('-rlmax', help='Reduced basis order per component for registration (default = 2,2,0)')
options.add_argument('-reg', help='Regularization for dwirecon (default = 0.01)')
#options.add_argument('-rf', help='Basis functions for the radial domain')
options.add_argument('-svr', help='Number of slice-to-volume reconstruction epochs (default = 0)')
options.add_argument('-mb', help='Multiband factor (default = 1)')
options.add_argument('-sorder', help='Slice order (default = 2,1, for odd-even)')
options.add_argument('-sspwidth', help='Slice thickness for Gaussian SSP (default = 1)')
options.add_argument('-sspfile', help='Slice sensitivity profile as vector')
options.add_argument('-or_loss', help='Outlier rejection loss function (default = softl1)')
options.add_argument('-fieldmap', help='B0 field map for distortion correction')
options.add_argument('-fieldidx', help='Index of volume to which field map is aligned (default = 0)')
options.add_argument('-pe_table', help='Phase encoding table in MRtrix format')
options.add_argument('-pe_eddy', nargs=2, help='Phase encoding table in FSL acqp/index format')
options.add_argument('-export_motion', help='Export rigid motion parameters')
options.add_argument('-export_weights', help='Export slice weights')
app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )
app.parse()


grad_import_option = ''
if app.args.grad:
    grad_import_option = ' -grad ' + path.fromUser(app.args.grad, True)
elif app.args.fslgrad:
    grad_import_option = ' -fslgrad ' + path.fromUser(app.args.fslgrad[0], True) + ' ' + path.fromUser(app.args.fslgrad[1], True)

pe_import_option = ''
if app.args.pe_table:
    pe_import_option = ' -import_pe_table ' + path.fromUser(app.args.pe_table, True)
elif app.args.pe_eddy:
    pe_import_option = ' -import_pe_eddy ' + path.fromUser(app.args.pe_eddy[0], True) + ' ' + path.fromUser(app.args.pe_eddy[1], True)


app.checkOutputPath(app.args.output)
if app.args.export_motion:
    app.checkOutputPath(app.args.export_motion)
if app.args.export_weights:
    app.checkOutputPath(app.args.export_weights)


app.makeTempDir()

run.command('mrconvert ' + path.fromUser(app.args.input, True) + ' ' + path.toTemp('in.mif', True) + grad_import_option + pe_import_option)
if app.args.mask:
    run.command('mrconvert ' + path.fromUser(app.args.mask, True) + ' ' + path.toTemp('mask.mif', True))
if app.args.fieldmap:
    run.command('mrconvert ' + path.fromUser(app.args.fieldmap, True) + ' ' + path.toTemp('field.mif', True))

app.gotoTempDir()


# Make sure it's actually a DWI that's been passed
dwi_sizes = image.headerField('in.mif', 'size').split()
if len(dwi_sizes) != 4:
    app.error('Input image must be a 4D image')
DW_scheme = image.headerField('in.mif', 'dwgrad').split('\n')
if len(DW_scheme) != int(dwi_sizes[3]):
    app.error('Input image does not contain valid DW gradient scheme')

# Check PE table if field map is passed.
if app.args.fieldmap:
    PE_scheme = image.headerField('in.mif', 'petable').split('\n')
    if len(PE_scheme) != int(dwi_sizes[3]):
        app.error('Input image does not contain valid phase encoding scheme')


# Generate a brain mask if required, or check the mask if provided
if app.args.mask:
    mask_sizes = image.headerField('mask.mif', 'size').split()
    if not mask_sizes[:3] == dwi_sizes[:3]:
        app.error('Provided mask image does not match input DWI')
else:
    run.command('dwi2mask in.mif mask.mif')


# Set no. iterations
v2viter = 3
if app.args.niter:
    v2viter = int(app.args.niter)
s2viter = 0
if app.args.svr:
    s2viter = int(app.args.svr)
niter = v2viter + s2viter

# Select shells
shells = [s.split('.')[0] for s in image.headerField('in.mif', 'shells').split()]
#if app.args.shells:
#    shells = app.args.shells.split(',')

# Set lmax
lmax = [4,]*len(shells)
lmax[0] = 0
if app.args.lmax:
    lmax = [int(l) for l in app.args.lmax.split(',')]
if len(lmax) != len(shells):
    app.error('No. lmax must match no. shells.')

rlmax = [2,2,0]
if app.args.rlmax:
    rlmax = [int(l) for l in app.args.rlmax.split(',')]
if len(rlmax) > len(lmax) or max(rlmax) > max(lmax):
    app.error('-rlmax invalid.')


# Shared reconstruction options
recon_option = '-maxiter 3'
if app.args.reg:
    recon_option += ' -reg ' + app.args.reg
if app.args.sspfile:
    recon_option += ' -ssp ' + path.fromUser(app.args.sspfile, True)
elif app.args.sspwidth:
    recon_option += ' -ssp ' + app.args.sspwidth
#if app.args.fieldmap:
#    recon_option += ' -field field1.mif'


# Initialise radial basis with RF per shell.
rfs = []
for k, l in enumerate(lmax):
    fn = 'rf'+str(k+1)+'.txt'
    with open(fn, 'w') as f:
        for s in range(len(shells)):
            if k==s:
                f.write(' '.join(['1',]*(l//2+1)) + '\n')
            else:
                f.write(' '.join(['0',]*(l//2+1)) + '\n')
    rfs += [fn,]

redrfs = ['redrf'+str(k+1)+'.txt' for k in range(len(rlmax))]

# Registration options
reg_option = '-type rigid -nonsymmetric -affine_niter 3'

# Force max no. threads
if app.args.nthreads:
    nthr = ' -nthreads ' + app.args.nthreads
else:
    nthr = ''

# Set multiband factor
mb = 1
if app.args.mb:
    mb = int(app.args.mb)

# Set OR loss
or_option = ' -mb ' + str(mb)
if app.args.or_loss:
    or_option += ' -loss ' + app.args.or_loss

# Slice order
motfilt_option = ' -extent 7'
if mb > 1:
    motfilt_option += ' -mb ' + str(mb)
if app.args.sorder:
    p,s = app.args.sorder.split(',')
    motfilt_option += ' -packs ' + p + ' -shift ' + s


# Image dimensions
dims = list(map(int, image.headerField('in.mif', 'size').split()))

vz = float(image.headerField('in.mif', 'vox').split()[2])
if app.args.sspwidth:
    vz *= float(app.args.sspwidth)

# Shell weights
with open('svdweights.txt', 'w') as f:
    f.write(image.headerField('in.mif', 'shellcount') + '\n')


#   __________ Function definitions __________

def reconstep(k):
    run.command('dwirecon in1.mif recon-' + str(k) + '.mif -spred spred.mif ' + recon_option + ' -rf ' + ' -rf '.join(rfs) +
            ('' if k==0 else ' -motion motion.txt -weights sliceweights.txt -init recon-' + str(k-1) + '.mif') + ' -force' + nthr)


def sliceweightstep():
    run.command('dwisliceoutliers in1.mif spred.mif -mask mask.mif sliceweights.txt' + or_option + ' -force')


def basisupdatestep(k):
    run.command('msshsvd recon-' + str(k) + '.mif -mask mask.mif -lmax ' + ','.join([str(l) for l in sorted(lmax)[::-1]]) +
                ' -weights svdweights.txt ' + ' '.join(rfs) + ' -force')


def rankreduxstep(k):
    run.command('msshsvd recon-' + str(k) + '.mif -mask mask.mif -lmax ' + ','.join([str(l) for l in rlmax]) +
                ' -weights svdweights.txt ' + ' '.join(redrfs) + ' -proj irankredux.mif -force')
    run.command('mrfilter irankredux.mif smooth rankredux.mif -fwhm 0,0,' + str(vz) + ' -force')


def v2vregstep(k):
    # register template to volumes
    prog = app.progressBar('Registering recon to data volumes', dims[3])
    for v in range(dims[3]):
        run.command('mrconvert -coord 3 ' + str(v) + ' in1.mif target.mif -export_grad_mrtrix grad1.txt -force')
        run.command('mssh2amp rankredux.mif grad1.txt template.mif ' + ('' if k==0 else '-transform T-' + str(v) + '.txt ') + '-force')
        run.command('mrreg_lin template.mif target.mif -mask2 mask.mif' + (' -affine_init T-'+str(v)+'.txt' if k>0 else '') +
                    ' -affine T-'+str(v)+'.txt ' + reg_option + ' -affine_scale ' + str(float(k+1)/v2viter) + ' -force')
        prog.increment()
    prog.done()
    run.command('motionfilter T ' + str(dims[3]) + ' 0 motion.txt -extent 1')


def s2vregstep(k):
    # register template to slices
    prog = app.progressBar('Registering recon to data slices', dims[3])
    for v in range(dims[3]):
        volmotion = ''
        run.command('mrconvert -coord 3 ' + str(v) + ' in1.mif target.mif -export_grad_mrtrix grad1.txt -force')
        if k == 0:
            run.command('mssh2amp rankredux.mif grad1.txt template.mif -transform T-' + str(v) + '.txt -force')
        for s in range(dims[2]//mb):
            run.command('maskslice -mb ' + str(mb) + ' mask.mif ' + str(s) + ' slicemask.mif -force')
            if k > 0:
                run.command('mssh2amp rankredux.mif grad1.txt template.mif -transform T-' + str(v) + '-' + str(s) + '.txt -force')
            run.command('mrreg_lin template.mif target.mif -mask2 slicemask.mif' +
                        ' -affine_init ' + ('T-'+str(v)+'-'+str(s)+'.txt' if k>0 else 'T-'+str(v)+'.txt') +
                        ' -affine T-'+str(v)+'-'+str(s)+'.txt ' + reg_option + ' -affine_scale ' + str(float(v2viter+k+1)/(v2viter+s2viter)) + ' -force')
        prog.increment()
    prog.done()
    run.command('motionfilter T ' + str(dims[3]) + ' ' + str(dims[2]) + ' motion.txt' + motfilt_option)


def fieldalignstep(k):
    if app.args.fieldmap:
        if k == 0:
            run.command('mrfieldunwarp in.mif field.mif in1.mif')
        else:
            idx = '0' if not app.args.fieldidx else app.args.fieldidx
            run.command('mrtransform field.mif -linear T-'+idx+'.txt -inverse field1.mif -force')
            run.command('mrfieldunwarp in.mif field1.mif -motion motion.txt in1.mif -force')
    else:
        if k == 0:
            run.command('mrconvert in.mif in1.mif')



#   __________ Motion correction __________

# initial template
fieldalignstep(0)
reconstep(0)

# volume-to-volume registration
for k in range(v2viter):
    sliceweightstep()
    basisupdatestep(k)
    # register template to volumes
    rankreduxstep(k)
    v2vregstep(k)
    fieldalignstep(k+1)
    # update template
    reconstep(k+1)

# slice-to-volume registration
for k in range(s2viter):
    sliceweightstep()
    basisupdatestep(v2viter+k)
    # register template to slices
    rankreduxstep(v2viter+k)
    s2vregstep(k)
    fieldalignstep(v2viter+k+1)
    # update template
    reconstep(v2viter+k+1)


#   __________ Copy outputs __________

run.command('mrconvert recon-'+str(v2viter+s2viter)+'.mif ' + path.fromUser(app.args.output, True) + (' -force' if app.force else ''))

if app.args.export_motion:
    run.command('cp motion.txt ' + path.fromUser(app.args.export_motion, True))

if app.args.export_weights:
    run.command('cp sliceweights.txt ' + path.fromUser(app.args.export_weights, True))


app.complete()




