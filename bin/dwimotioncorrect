#!/usr/bin/env python

#   MOTION CORRECTION FOR DWI VOLUME SERIES
#
#   This script performs volume-to-series and slice-to-series registration
#   of diffusion-weighted images for motion correction in the brain.
#
#   Author:  Daan Christiaens
#            King's College London
#            daan.christiaens@kcl.ac.uk
#

#   __________ Initialisation __________

# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys, subprocess
p = subprocess.Popen(['which', 'mrinfo'], stdout=subprocess.PIPE)
line = p.stdout.readline().decode().strip()
lib_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(line)[0], os.pardir, 'lib')))
if not os.path.isdir(lib_folder):
    sys.stderr.write('Unable to locate MRtrix3 Python libraries')
    sys.exit(1)
sys.path.insert(0, lib_folder)
from mrtrix3 import app, fsl, image, path, run


app.init('Daan Christiaens (daan.christiaens@kcl.ac.uk)',
         'Perform motion correction for a DWI volume series')

app.cmdline.add_argument('input',  help='The input image series to be corrected')
app.cmdline.add_argument('output', help='The output multi-shell SH coefficients')

options = app.cmdline.add_argument_group('Options for the dwimotioncorrect script')
options.add_argument('-mask', help='Manually provide a mask image for motion correction')
options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
options.add_argument('-niter', help='Number of epochs (default = 3)')
options.add_argument('-lmax', help='SH basis order per shell (default = 0,4,4,...)')
options.add_argument('-rlmax', help='Reduced basis order per component for registration (default = 2,2,0)')
options.add_argument('-reg', help='Regularization for dwirecon (default = 0.01)')
options.add_argument('-lbreg', help='Laplace-Beltrami regularization for SHARD (default = 0.01)')
options.add_argument('-svr', help='Number of slice-to-volume reconstruction epochs (default = 0)')
options.add_argument('-mb', help='Multiband factor (default = 1)')
options.add_argument('-sorder', help='Slice order (default = 2,1, for odd-even)')
options.add_argument('-sspwidth', help='Slice thickness for Gaussian SSP (default = 1)')
options.add_argument('-sspfile', help='Slice sensitivity profile as vector')
options.add_argument('-or_loss', help='Outlier rejection loss function (default = softl1)')
options.add_argument('-matchintensity', help='Activate "slice" or "full" intensity matching (default = off)')
options.add_argument('-fieldmap', help='B0 field map for distortion correction')
options.add_argument('-fieldidx', help='Index of volume to which field map is aligned (default = 0)')
options.add_argument('-pe_table', help='Phase encoding table in MRtrix format')
options.add_argument('-pe_eddy', nargs=2, help='Phase encoding table in FSL acqp/index format')
options.add_argument('-export_motion', help='Export rigid motion parameters')
options.add_argument('-export_weights', help='Export slice weights')
app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )
app.parse()


grad_import_option = ''
if app.args.grad:
    grad_import_option = ' -grad ' + path.fromUser(app.args.grad, True)
elif app.args.fslgrad:
    grad_import_option = ' -fslgrad ' + path.fromUser(app.args.fslgrad[0], True) + ' ' + path.fromUser(app.args.fslgrad[1], True)

pe_import_option = ''
if app.args.pe_table:
    pe_import_option = ' -import_pe_table ' + path.fromUser(app.args.pe_table, True)
elif app.args.pe_eddy:
    pe_import_option = ' -import_pe_eddy ' + path.fromUser(app.args.pe_eddy[0], True) + ' ' + path.fromUser(app.args.pe_eddy[1], True)


app.checkOutputPath(app.args.output)
if app.args.export_motion:
    app.checkOutputPath(app.args.export_motion)
if app.args.export_weights:
    app.checkOutputPath(app.args.export_weights)


app.makeTempDir()

run.command('mrconvert ' + path.fromUser(app.args.input, True) + ' ' + path.toTemp('in.mif', True) + grad_import_option + pe_import_option)
if app.args.mask:
    run.command('mrconvert ' + path.fromUser(app.args.mask, True) + ' ' + path.toTemp('mask.mif', True))
if app.args.fieldmap:
    run.command('mrconvert ' + path.fromUser(app.args.fieldmap, True) + ' ' + path.toTemp('field.mif', True))

app.gotoTempDir()


# Make sure it's actually a DWI that's been passed
dwi_sizes = image.headerField('in.mif', 'size').split()
if len(dwi_sizes) != 4:
    app.error('Input image must be a 4D image')
DW_scheme = image.headerField('in.mif', 'dwgrad').split('\n')
if len(DW_scheme) != int(dwi_sizes[3]):
    app.error('Input image does not contain valid DW gradient scheme')

# Check PE table if field map is passed.
if app.args.fieldmap:
    PE_scheme = image.headerField('in.mif', 'petable').split('\n')
    if len(PE_scheme) != int(dwi_sizes[3]):
        app.error('Input image does not contain valid phase encoding scheme')


# Generate a brain mask if required, or check the mask if provided
if app.args.mask:
    mask_sizes = image.headerField('mask.mif', 'size').split()
    if not mask_sizes[:3] == dwi_sizes[:3]:
        app.error('Provided mask image does not match input DWI')
else:
    run.command('dwi2mask in.mif mask.mif')


# Image dimensions
dims = list(map(int, image.headerField('in.mif', 'size').split()))
vox = list(map(float, image.headerField('in.mif', 'vox').split()))
vu = round((vox[0]+vox[1])/2., 1)
shells = [s.split('.')[0] for s in image.headerField('in.mif', 'shells').split()]


# Configuration
class Config:
    def __init__(self, svr=False, recit=5, regit=10, scale=1.):
        self.svr = svr
        self.recit = recit
        self.regit = regit
        self.scale = scale

#iters = [Config(False, 3, 10, 4.00),
#         Config(False, 5, 10, 2.00),
#         Config(False, 5, 10, 1.00),
#         Config(True,  5, 10, 2.00),
#         Config(True, 10, 10, 1.00),
#         Config(True, 10, 10, 0.50),
#         Config(True, 10, 10, 0.25),
#         Config(True, 50, -1, 0.00)]

#iters = [Config(False, 3, 10, 4.00),
#         Config(False, 5, 10, 2.00),
#         Config(True,  5, 10, 1.00),
#         Config(True,  5, 10, 0.50),
#         Config(True,  5, 10, 0.25),
#         Config(True, 25, -1, 0.00)]

iters = [Config(False, 3, 50, 0.20),
         Config(False, 5, 50, 0.10),
         Config(True,  5, 50, 0.05),
         Config(True, 10, 50, 0.02),
         Config(True, 50, -1, 0.01)]


# Set lmax
lmax = [0,] + [4,]*(len(shells)-1)
if app.args.lmax:
    lmax = [int(l) for l in app.args.lmax.split(',')]
if len(lmax) != len(shells):
    app.error('No. lmax must match no. shells.')

rlmax = [2,2,0]
if app.args.rlmax:
    rlmax = [int(l) for l in app.args.rlmax.split(',')]
if len(rlmax) > len(lmax) or max(rlmax) > max(lmax):
    app.error('-rlmax invalid.')

lbreg = float(app.args.lbreg) if app.args.lbreg else 0.01


# Shared reconstruction options
#recon_option = ''
#if app.args.reg:
#    recon_option += '-reg ' + app.args.reg


# SSP option
ssp_option = ''
if app.args.sspfile:
    run.command('cp ' + path.fromUser(app.args.sspfile, True) + ' ssp.txt')
    ssp_option = ' -ssp ssp.txt'
elif app.args.sspwidth:
    ssp_option = ' -ssp ' + app.args.sspwidth


# Initialise radial basis with RF per shell.
rfs = []
for k, l in enumerate(lmax):
    fn = 'rf'+str(k+1)+'.txt'
    with open(fn, 'w') as f:
        for s in range(len(shells)):
            if k==s:
                f.write(' '.join(['1',]*(l//2+1)) + '\n')
            else:
                f.write(' '.join(['0',]*(l//2+1)) + '\n')
    rfs += [fn,]

redrfs = ['redrf'+str(k+1)+'.txt' for k in range(len(rlmax))]

# Force max no. threads
if app.args.nthreads:
    nthr = ' -nthreads ' + app.args.nthreads
else:
    nthr = ''

# Set multiband factor
mb = 1
if app.args.mb:
    mb = int(app.args.mb)

# Set OR loss
or_option = ' -mb ' + str(mb)
if app.args.or_loss:
    or_option += ' -loss ' + app.args.or_loss

# Slice order
motfilt_option = ''
if app.args.sorder:
    p,s = app.args.sorder.split(',')
    motfilt_option += ' -packs ' + p + ' -shift ' + s


# Variable input file name
inputfn = 'in.mif'



#   __________ Function definitions __________

def reconstep(k, scale=1.):
    im = inputfn;
    if k > 0 and app.args.matchintensity:
        im = 'scaled.mif'
        run.command('mrcalc ' + inputfn + (' biasfield.mif -exp -mult' if app.args.matchintensity=='full' else '') + ' imscale.mif -mult ' + im + ' -force')
    run.command('dwirecon ' + im + ' recon-' + str(k) + '.mif -spred spred.mif -maxiter ' + str(iters[k].recit) + ' -reg ' + str(iters[k].scale) + ' ' + ssp_option + ' -rf ' + ' -rf '.join(rfs) +
            ('' if k==0 else ' -motion motion.txt -weights sliceweights.txt -init recon-' + str(k-1) + '.mif') + ' -force' + nthr)


def sliceweightstep():
    if app.args.matchintensity:
        run.command('dwisliceoutliers ' + inputfn + ' spred.mif -mask mask.mif sliceweights.txt' + or_option + ' -imscale imscale.mif -force')
        if app.args.matchintensity == 'full':
            run.command('mrcalc spred.mif -abs -log in.mif -abs -log -sub - ' +
                        '| mrfilter - smooth - -stdev 5,5,0 -extent 45,45,1 | mrcalc - biasfield.mif -force')
            run.command('mrcalc biasfield.mif mask.mif -mult - | mrmath -axis 0 - sum - | mrmath -axis 1 - sum tmp1.mif -force')
            run.command('mrmath -axis 0 mask.mif sum - | mrmath -axis 1 - sum tmp2.mif -force')
            run.command('mrcalc biasfield.mif tmp2.mif 0 -eq 0 tmp1.mif tmp2.mif -divide -if -sub - | mrconvert - biasfield.mif -force')
            #run.command('mrmath -axis 0 biasfield.mif mean - | mrmath -axis 1 - mean - | mrcalc biasfield.mif - -sub - | mrconvert - biasfield.mif -force')
    else:
        run.command('dwisliceoutliers ' + inputfn + ' spred.mif -mask mask.mif sliceweights.txt' + or_option + ' -force')


def basisupdatestep(k):
    run.command('msshsvd recon-' + str(k) + '.mif -mask mask.mif -lmax ' + ','.join([str(l) for l in sorted(lmax)[::-1]]) +
                ' -lbreg ' + str(lbreg) + ' ' + ' '.join(rfs) + ' -force')


def rankreduxstep(k):
    run.command('msshsvd recon-' + str(k) + '.mif -mask mask.mif -lmax ' + ','.join([str(l) for l in rlmax]) +
                ' -lbreg ' + str(lbreg) + ' ' + ' '.join(redrfs) + ' -proj rankredux.mif -force')


def registrationstep(k):
    run.command('dwislicealign ' + inputfn + ' rankredux.mif motion.txt -mask mask.mif -maxiter ' + str(iters[k].regit) +
                ' -mb ' + (str(mb) if iters[k].svr else '0') + (' -init motion.txt' if k>0 else '') +
                ssp_option + ' -force' + nthr)
    if app.args.sorder:
        run.command('motionfilter motion.txt sliceweights.txt motion.txt' + motfilt_option)


def fieldalignstep(k):
    global inputfn
    if app.args.fieldmap:
        if k == 0:
            run.command('mrfieldunwarp in.mif field.mif unwarped.mif')
        else:
            fidx = '-fidx ' + ('0' if not app.args.fieldidx else app.args.fieldidx)
            run.command('mrfieldunwarp in.mif field.mif -motion motion.txt ' + fidx + ' unwarped.mif -force')
        inputfn = 'unwarped.mif'



#   __________ Motion correction __________

# initial template
fieldalignstep(0)
reconstep(0)

# running reconstruction
for k, it in enumerate(iters[:-1]):
    # basis update and rank reduction
    basisupdatestep(k)
    rankreduxstep(k)
    # slice weights
    sliceweightstep()
    # register template to volumes
    registrationstep(k)
    fieldalignstep(k+1)
    # update template
    reconstep(k+1)


#   __________ Copy outputs __________

run.command('mrconvert recon-'+str(len(iters)-1)+'.mif ' + path.fromUser(app.args.output, True) + (' -force' if app.force else ''))

if app.args.export_motion:
    run.command('cp motion.txt ' + path.fromUser(app.args.export_motion, True))

if app.args.export_weights:
    run.command('cp sliceweights.txt ' + path.fromUser(app.args.export_weights, True))


app.complete()




