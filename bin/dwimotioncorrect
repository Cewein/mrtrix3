#!/usr/bin/env python

#   Copyright (c) 2017-2019 Daan Christiaens
#
#   MRtrix and this add-on module are distributed in the hope
#   that it will be useful, but WITHOUT ANY WARRANTY; without
#   even the implied warranty of MERCHANTABILITY or FITNESS
#   FOR A PARTICULAR PURPOSE.
#
#   MOTION CORRECTION FOR DWI VOLUME SERIES
#
#   This script performs volume-to-series and slice-to-series registration
#   of diffusion-weighted images for motion correction in the brain.
#
#   Author:  Daan Christiaens
#            King's College London
#            daan.christiaens@kcl.ac.uk
#

import mrtrix3
from mrtrix3 import app, image, path, run


def usage(cmdline): #pylint: disable=unused-variable
    # base
    cmdline.set_author('Daan Christiaens (daan.christiaens@kcl.ac.uk)')
    cmdline.set_synopsis('Perform motion correction in a dMRI dataset')
    cmdline.add_description('Volume-level and/or slice-level motion correction for dMRI, '
                            'based on the SHARD representation for multi-shell data. ')
    # arguments
    cmdline.add_argument('input',  help='The input image series to be corrected')
    cmdline.add_argument('output', help='The output multi-shell SH coefficients')
    # options
    options = cmdline.add_argument_group('Options for the dwimotioncorrect script')
    options.add_argument('-mask', help='Manually provide a mask image for motion correction')
    options.add_argument('-lmax', help='SH basis order per shell (default = 0,4,4,...)')
    options.add_argument('-rlmax', help='Reduced basis order per component for registration (default = 2,2,0)')
    options.add_argument('-reg', help='Regularization for dwirecon (default = 0.001)')
    options.add_argument('-zreg', help='Regularization for dwirecon (default = 0.01)')
    options.add_argument('-lbreg', help='Laplace-Beltrami regularization for SHARD (default = 0)')
    options.add_argument('-v2v', action='store_true', help='Constrain to volume-level motion correction only')
    options.add_argument('-mb', help='Multiband factor (default = 1)')
    options.add_argument('-sorder', help='Slice order (default = 2,1, for odd-even)')
    options.add_argument('-sspwidth', help='Slice thickness for Gaussian SSP (default = 1)')
    options.add_argument('-sspfile', help='Slice sensitivity profile as vector')
    options.add_argument('-fieldmap', help='B0 field map for distortion correction')
    options.add_argument('-fieldidx', help='Index of volume to which field map is aligned (default = 0)')
    options.add_argument('-pe_table', help='Phase encoding table in MRtrix format')
    options.add_argument('-pe_eddy', nargs=2, help='Phase encoding table in FSL acqp/index format')
    options.add_argument('-priorweights', help='Import prior slice weights')
    options.add_argument('-fixedweights', help='Import prior slice weights')
    options.add_argument('-export_motion', help='Export rigid motion parameters')
    options.add_argument('-export_weights', help='Export slice weights')
    app.add_dwgrad_import_options(cmdline)



def execute(): #pylint: disable=unused-variable
    # import metadata
    grad_import_option = app.read_dwgrad_import_options()
    pe_import_option = ''
    if app.ARGS.pe_table:
        pe_import_option = ' -import_pe_table ' + path.from_user(app.ARGS.pe_table, True)
    elif app.ARGS.pe_eddy:
        pe_import_option = ' -import_pe_eddy ' + path.from_user(app.ARGS.pe_eddy[0], True) + ' ' + path.from_user(app.ARGS.pe_eddy[1], True)
    # check output path
    app.check_output_path(app.ARGS.output)
    if app.ARGS.export_motion:
        app.check_output_path(app.ARGS.export_motion)
    if app.ARGS.export_weights:
        app.check_output_path(app.ARGS.export_weights)
    # prepare working directory
    app.make_scratch_dir()
    run.command('mrconvert ' + path.from_user(app.ARGS.input, True) + ' ' + path.to_scratch('in.mif', True) + grad_import_option + pe_import_option)
    if app.ARGS.mask:
        run.command('mrconvert ' + path.from_user(app.ARGS.mask, True) + ' ' + path.to_scratch('mask.mif', True))
    if app.ARGS.fieldmap:
        run.command('mrconvert ' + path.from_user(app.ARGS.fieldmap, True) + ' ' + path.to_scratch('field.mif', True))
    app.goto_scratch_dir()

    # Make sure it's actually a DWI that's been passed
    header = image.Header('in.mif')
    dwi_sizes = header.size()
    if len(dwi_sizes) != 4:
        app.error('Input image must be a 4D image')
    DW_scheme = image.mrinfo('in.mif', 'dwgrad').split('\n')
    if len(DW_scheme) != int(dwi_sizes[3]):
        app.error('Input image does not contain valid DW gradient scheme')

    # Check PE table if field map is passed.
    if app.ARGS.fieldmap:
        PE_scheme = image.mrinfo('in.mif', 'petable').split('\n')
        if len(PE_scheme) != int(dwi_sizes[3]):
            app.error('Input image does not contain valid phase encoding scheme')

    # Generate a brain mask if required, or check the mask if provided
    if app.ARGS.mask:
        if not image.match(header, 'mask.mif', up_to_dim=3):
            app.error('Provided mask image does not match input DWI')
    else:
        run.command('dwi2mask in.mif mask.mif')

    # Image dimensions
    dims = list(map(int, header.size()))
    vox = list(map(float, header.spacing()))
    vu = round((vox[0]+vox[1])/2., 1)
    shells = [s.split('.')[0] for s in image.mrinfo('in.mif', 'shell_bvalues').split()]

    # Set lmax
    lmax = [0,] + [4,]*(len(shells)-1)
    if app.ARGS.lmax:
        lmax = [int(l) for l in app.ARGS.lmax.split(',')]
    if len(lmax) != len(shells):
        app.error('No. lmax must match no. shells.')

    rlmax = [2,2,0]
    if app.ARGS.rlmax:
        rlmax = [int(l) for l in app.ARGS.rlmax.split(',')]
    if len(rlmax) > len(lmax) or max(rlmax) > max(lmax):
        app.error('-rlmax invalid.')

    # Regularization options
    reg_option = ''
    if app.ARGS.reg:
        reg_option += ' -reg ' + app.ARGS.reg
    if app.ARGS.zreg:
        reg_option += ' -zreg ' + app.ARGS.zreg

    # SSP option
    ssp_option = ''
    if app.ARGS.sspfile:
        run.command('cp ' + path.from_user(app.ARGS.sspfile, True) + ' ssp.txt')
        ssp_option = ' -ssp ssp.txt'
    elif app.ARGS.sspwidth:
        ssp_option = ' -ssp ' + app.ARGS.sspwidth

    # Initialise radial basis with RF per shell.
    rfs = []
    for k, l in enumerate(lmax):
        fn = 'rf'+str(k+1)+'.txt'
        with open(fn, 'w') as f:
            for s in range(len(shells)):
                i = '1' if k==s else '0'
                f.write(' '.join([i,]*(l//2+1)) + '\n')
        rfs += [fn,]

    redrfs = ['redrf'+str(k+1)+'.txt' for k in range(len(rlmax))]

    # Force max no. threads
    nthr = ''
    if app.ARGS.nthreads:
        nthr = ' -nthreads ' + app.ARGS.nthreads

    # Slice-level motion?
    slm = not app.ARGS.v2v

    # Set multiband factor
    mb = 1
    if app.ARGS.mb:
        mb = int(app.ARGS.mb)

    # Slice order
    motfilt_option = ''
    if app.ARGS.sorder:
        p,s = app.ARGS.sorder.split(',')
        motfilt_option += ' -packs ' + p + ' -shift ' + s

    # Import fixed slice weights
    if app.ARGS.priorweights:
        run.command('cp ' + path.from_user(app.ARGS.priorweights, True) + ' priorweights.txt')
    if app.ARGS.fixedweights:
        run.command('cp ' + path.from_user(app.ARGS.fixedweights, True) + ' sliceweights.txt')

    # Configuration
    class Config:
        def __init__(self, svr=False, recit=5, regit=10, scale=1.):
            self.svr = svr
            self.recit = recit
            self.regit = regit
            self.scale = scale


    iters = [Config(False, 3, 10, 3.0),
             Config(False, 3, 10, 2.4),
             Config(slm,   3, 10, 1.9),
             Config(slm,   3, 10, 1.5),
             Config(slm,   3, 10, 1.2),
             Config(slm,  10, -1, 1.0)]


    # Variable input file name
    global inputfn
    inputfn = 'in.mif'


    #   __________ Function definitions __________

    def reconstep(k):
        im = inputfn;
        rcmd = 'dwirecon ' + im + ' recon-' + str(k) + '.mif -spred spred.mif -maxiter ' + str(iters[k].recit)
        rcmd += reg_option + ssp_option + ' -rf ' + ' -rf '.join(rfs)
        if k>0:
            rcmd += ' -motion motion.txt -weights sliceweights.txt -init recon-' + str(k-1) + '.mif'
        elif app.ARGS.priorweights:
            rcmd += ' -weights priorweights.txt'
        rcmd += ' -force' + nthr
        run.command(rcmd)


    def sliceweightstep(k):
        if app.ARGS.fixedweights:
            return;
        mask_opt = ' -mask mask.mif' + (' -motion motion.txt' if k>0 else '')
        run.command('dwisliceoutliergmm ' + inputfn + ' spred.mif -mb ' + str(mb) + mask_opt + ' sliceweights.txt -force')
        if app.ARGS.priorweights:
            import numpy as np
            W0 = np.loadtxt('priorweights.txt')
            W1 = np.loadtxt('sliceweights.txt')
            np.savetxt('sliceweights.txt', W1 * W0)


    def basisupdatestep(k):
        run.command('msshsvd recon-' + str(k) + '.mif -mask mask.mif -lmax ' + ','.join([str(l) for l in sorted(lmax)[::-1]]) +
                    (' -lbreg ' + app.ARGS.lbreg if app.ARGS.lbreg else '') + ' ' + ' '.join(rfs) + ' -force')


    def rankreduxstep(k, scale=1.):
        run.command('mrfilter recon-' + str(k) + '.mif smooth - -fwhm ' + str(round(vu*scale, 2)) + ' | ' +
                    'msshsvd - -mask mask.mif -lmax ' + ','.join([str(l) for l in rlmax]) +
                    (' -lbreg ' + app.ARGS.lbreg if app.ARGS.lbreg else '') + ' ' + ' '.join(redrfs) + ' -proj rankredux.mif -force')


    def registrationstep(k):
        run.command('dwislicealign ' + inputfn + ' rankredux.mif motion.txt -mask mask.mif -maxiter ' + str(iters[k].regit) +
                    ' -mb ' + (str(mb) if iters[k].svr else '0') + (' -init motion.txt' if k>0 else '') +
                    ssp_option + ' -force' + nthr)
        if app.ARGS.sorder:
            run.command('motionfilter motion.txt sliceweights.txt motion.txt -medfilt 5' + motfilt_option)


    def fieldalignstep(k):
        global inputfn
        if app.ARGS.fieldmap:
            if k == 0:
                run.command('mrfieldunwarp in.mif field.mif unwarped.mif')
            else:
                fidx = '-fidx ' + ('0' if not app.ARGS.fieldidx else app.ARGS.fieldidx)
                run.command('mrfieldunwarp in.mif field.mif -motion motion.txt ' + fidx + ' unwarped.mif -force')
            inputfn = 'unwarped.mif'


    #   __________ Motion correction __________

    # initial template
    fieldalignstep(0)
    reconstep(0)

    # running reconstruction
    for k, it in enumerate(iters[:-1]):
        # basis update and rank reduction
        basisupdatestep(k)
        rankreduxstep(k, it.scale)
        # slice weights
        sliceweightstep(k)
        # register template to volumes
        registrationstep(k)
        fieldalignstep(k+1)
        # update template
        reconstep(k+1)


    #   __________ Copy outputs __________

    run.command('mrconvert recon-'+str(len(iters)-1)+'.mif ' + path.from_user(app.ARGS.output, True) + (' -force' if app.FORCE_OVERWRITE else ''))
    if app.ARGS.export_motion:
        run.command('cp motion.txt ' + path.from_user(app.ARGS.export_motion, True))
    if app.ARGS.export_weights:
        run.command('cp sliceweights.txt ' + path.from_user(app.ARGS.export_weights, True))


mrtrix3.execute()

