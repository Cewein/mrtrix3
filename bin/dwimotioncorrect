#!/usr/bin/env python

#   MOTION CORRECTION FOR DWI VOLUME SERIES
#
#   This script performs volume-to-series and slice-to-series registration
#   of diffusion-weighted images for motion correction in the brain.
#
#   Author:  Daan Christiaens
#            King's College London
#            daan.christiaens@kcl.ac.uk
#

#   __________ Initialisation __________

# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys, subprocess
p = subprocess.Popen(['which', 'mrinfo'], stdout=subprocess.PIPE)
line = p.stdout.readline().decode().strip()
lib_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(line)[0], os.pardir, 'lib')))
if not os.path.isdir(lib_folder):
    sys.stderr.write('Unable to locate MRtrix3 Python libraries')
    sys.exit(1)
sys.path.insert(0, lib_folder)
from mrtrix3 import app, fsl, image, path, run


app.init('Daan Christiaens (daan.christiaens@kcl.ac.uk)',
         'Perform motion correction for a DWI volume series')

app.cmdline.add_argument('input',  help='The input image series to be corrected')
app.cmdline.add_argument('output', help='The output corrected image series')

options = app.cmdline.add_argument_group('Options for the dwimotioncorrect script')
options.add_argument('-mask', help='Manually provide a mask image for motion correction')
options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
options.add_argument('-niter', help='Number of epochs (default = 3)')
options.add_argument('-shells', help='Shells to be processed (default = all)')
options.add_argument('-lmax', help='SH basis order for single-shell processing (default = 0)')
options.add_argument('-reg', help='Regularization for dwirecon (default = 0.01)')
#options.add_argument('-rf', help='Basis functions for the radial domain')
options.add_argument('-svr', help='Number of slice-to-volume reconstruction epochs (default = 0)')
options.add_argument('-mb', help='Multiband factor (default = 1)')
options.add_argument('-sspwidth', help='Slice thickness for Gaussian SSP. (default = 1)')
options.add_argument('-or_thr', help='Outlier rejection threshold (default = 3.0)')
app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )
app.parse()


grad_import_option = ''
if app.args.grad:
    grad_import_option = ' -grad ' + path.fromUser(app.args.grad, True)
elif app.args.fslgrad:
    grad_import_option = ' -fslgrad ' + path.fromUser(app.args.fslgrad[0], True) + ' ' + path.fromUser(app.args.fslgrad[1], True)


nout, eout = os.path.splitext(app.args.output)
outvi = nout + eout
outvc = nout + '-rc' + eout
app.checkOutputPath(outvi)
app.checkOutputPath(outvc)
if app.args.svr is not None and int(app.args.svr) > 0:
    outsi = nout + '-svr' + eout
    outsc = nout + '-svr-rc' + eout
    app.checkOutputPath(outsi)
    app.checkOutputPath(outsc)


app.makeTempDir()

run.command('mrconvert ' + path.fromUser(app.args.input, True) + ' ' + path.toTemp('in.mif', True) + grad_import_option)
if app.args.mask:
    run.command('mrconvert ' + path.fromUser(app.args.mask, True) + ' ' + path.toTemp('mask.mif', True))

app.gotoTempDir()


# Make sure it's actually a DWI that's been passed
dwi_sizes = image.headerField('in.mif', 'size').split()
if len(dwi_sizes) != 4:
    app.error('Input image must be a 4D image')
DW_scheme = image.headerField('in.mif', 'dwgrad').split('\n')
if len(DW_scheme) != int(dwi_sizes[3]):
    app.error('Input image does not contain valid DW gradient scheme')


# Generate a brain mask if required, or check the mask if provided
if app.args.mask:
    mask_sizes = image.headerField('mask.mif', 'size').split()
    if not mask_sizes[:3] == dwi_sizes[:3]:
        app.error('Provided mask image does not match input DWI')
else:
    run.command('dwi2mask in.mif mask.mif')


# Set no. iterations
v2viter = 3
if app.args.niter:
    v2viter = int(app.args.niter)
s2viter = 0
if app.args.svr:
    s2viter = int(app.args.svr)
niter = v2viter + s2viter

# Select shells
shells = image.headerField('in.mif', 'shells').split()
if app.args.shells:
    shells = app.args.shells.split(',')

# Set lmax
lmax = [0,]
if app.args.lmax:
    lmax = [int(l) for l in app.args.lmax]
if len(lmax) != len(shells):
    app.error('No. lmax must match no. shells.')


#if shell=='0' and lmax>0:
#    app.error('Option -lmax ' + str(lmax) + ' incompatible with b=0 shell.')

# Radial basis
#rf_import_option = ''
#if app.args.rf:
#    rf_import_option = ' '.join('-rf ' + path.fromUser(r, True) for r in app.args.rf.split(','))

# Shared reconstruction options
recon_option = '-maxiter 1'
if app.args.reg:
    recon_option += ' -reg ' + app.args.reg
if app.args.sspwidth:
    recon_option += ' -sspwidth ' + app.args.sspwidth

#if rf_import_option is not '':
#    recon_option += rf_import_option
#elif shell is not None and len(shell)==1:
#    recon_option += ' -lmax ' + str(lmax)
#else:
#    app.error('Multi-shell data requires radial basis, single-shell data requires lmax.')

reg_option = '-type rigid -nonsymmetric -affine_scale 1.0 -affine_niter 3'

# Force max no. threads
if app.args.nthreads:
    nthr = ' -nthreads ' + app.args.nthreads
else:
    nthr = ''

# Set multiband factor
mb = 1
if app.args.mb:
    mb = int(app.args.mb)

# Set OR threshold
ort = ''
if app.args.or_thr:
    ort = ' -thr ' + app.args.or_thr

# Image dimensions
dims = list(map(int, image.headerField('in.mif', 'size').split()))


#   __________ Function definitions __________

def reconstep(i):
    n = max(lmax)
    n = (n+1)*(n+2)//2
    tmpsh = ['sh-b' + s + '.mif' for s in shells]
    for s, l, fn in zip(shells, lmax, tmpsh):
        run.command('dwirecon in.mif -shell ' + s + ' -lmax ' + str(l) + ' -motion motion.txt ' +
                    fn + ('' if i==0 else ' -weights sliceweights.txt -init ' + fn) +
                    ' -spred spred-b' + s + '.mif -pad ' + str(n) + ' ' + recon_option + ' -force' + nthr)
    run.command('mrcat -axis 5 ' + ' '.join(tmpsh) + ' - | mrconvert -axes 0,1,2,4,3 -set_property shells ' +
                ','.join(shells) + ' - recon-' + str(i) + '.mif')
    run.command('mrmath ' + ' '.join(['spred-b' + s + '.mif' for s in shells]) + ' sum spred.mif -force')


def sliceweightstep():
    run.command('dwisliceoutliers in.mif spred.mif -mask mask.mif sliceweights.txt -force' + ort)


def rankreduxstep(i):
    run.command('msshsvd recon-' + str(i) + '.mif -mask mask.mif -lmax 4 msshredux.mif -force')


def v2vstep(k):
    # register template to slices
    with open('motion.txt', 'w') as f:
        prog = app.progressBar('Registering recon to data volumes', dims[3])
        for v in range(dims[3]):
            run.command('mrconvert -coord 3 ' + str(v) + ' in.mif target.mif -export_grad_mrtrix grad1.txt -force')
            run.command('mssh2amp msshredux.mif grad1.txt template.mif -transform T-' + str(v) + '.txt -force')
            run.command('mrreg_lin template.mif target.mif -mask2 slicemask.mif' +
                        ' -affine_init ' + ('T-'+str(v)+'.txt' if k>0 else '') +
                        ' -affine T-'+str(v)+'.txt ' + reg_option + ' -force')
            run.command('transformcalc T-'+str(v)+'.txt decompose trafo.txt -force')
            with open('trafo.txt') as f2:
                L = f2.readlines()
            tra = L[4].strip().split(':')[1].strip()    # translation
            rot = L[2].strip().split(':')[1].strip()    # rotation
            f.write(tra + ' ' + rot + '\n')
            prog.increment()
        prog.done()


def s2vstep(k):
    # register template to slices
    with open('motion.txt', 'w') as f:
        prog = app.progressBar('Registering recon to data slices', dims[3]*dims[2]//mb)
        for v in range(dims[3]):
            volmotion = ''
            run.command('mrconvert -coord 3 ' + str(v) + ' in.mif target.mif -export_grad_mrtrix grad1.txt -force')
            if k == 0:
                run.command('mssh2amp msshredux.mif grad1.txt template.mif -transform T-' + str(v) + '.txt -force')
            for s in range(dims[2]//mb):
                run.command('maskslice -mb ' + str(mb) + ' mask.mif ' + str(s) + ' slicemask.mif -force')
                if k > 0:
                    run.command('mssh2amp msshredux.mif grad1.txt template.mif -transform T-' + str(v) + '-' + str(s) + '.txt -force')
                run.command('mrreg_lin template.mif target.mif -mask2 slicemask.mif' +
                        ' -affine_init ' + ('T-'+str(v)+'-'+str(s)+'.txt' if k>0 else 'T-'+str(v)+'.txt') +
                        ' -affine T-'+str(v)+'-'+str(s)+'.txt ' + reg_option + ' -force')
                run.command('transformcalc T-'+str(v)+'-'+str(s)+'.txt decompose trafo.txt -force')
                with open('trafo.txt') as f2:
                    L = f2.readlines()
                tra = L[4].strip().split(':')[1].strip()    # translation
                rot = L[2].strip().split(':')[1].strip()    # rotation
                volmotion += tra + ' ' + rot + '\n'
                prog.increment()
            for m in range(mb):
                f.write(volmotion)
        prog.done()



#   __________ Motion correction __________

# Split shells for SH recon
for s in shells:
    run.command('dwiextract -shell ' + s + ' in.mif in-b' + s + '.mif')






shell = None
# select shells
if shell is not None:
    run.command('dwiextract -shell ' + ','.join(shell) + ' in.mif shells.mif')
else:
    run.command('mrconvert in.mif shells.mif')
dims = list(map(int, image.headerField('shells.mif', 'size').split()))

# initial template
run.command('dwirecon shells.mif ' + recon_option + ' recon-0.mif -rpred pred.mif -spred spred.mif' + nthr)
run.command('dwisliceoutliers shells.mif spred.mif -mask mask.mif sliceweights.txt' + ort)

# volume-to-volume registration
for k in range(v2viter):
    # register template to volumes
    with open('motion.txt', 'w') as f:
        prog = app.progressBar('Registering recon to data volumes', dims[3])
        for v in range(dims[3]):
            run.command('mrconvert -coord 3 ' + str(v) + ' pred.mif template.mif -force')
            run.command('mrconvert -coord 3 ' + str(v) + ' shells.mif target.mif -force')
            run.command('mrreg_lin template.mif target.mif -nonsymmetric -mask2 mask.mif' +
                        ' -type rigid ' + ('-affine_init T-'+str(v)+'.txt' if k>0 else '') +
                        ' -affine_scale 1.0 -affine T-'+str(v)+'.txt -affine_niter 3 -force')
            run.command('transformcalc T-'+str(v)+'.txt decompose trafo.txt -force')
            with open('trafo.txt') as f2:
                L = f2.readlines()
            tra = L[4].strip().split(':')[1].strip()    # translation
            rot = L[2].strip().split(':')[1].strip()    # rotation
            f.write(tra + ' ' + rot + '\n')
            prog.increment()
        prog.done()
    # update template
    run.command('dwirecon shells.mif ' + recon_option + ' recon-'+str(k+1)+'.mif -motion motion.txt' +
                ' -weights sliceweights.txt -init recon-'+str(k)+'.mif -rpred pred.mif' +
                ' -spred spred.mif' + (' -tpred result-v.mif' if k+1==v2viter else '') + ' -force' + nthr)
    run.command('dwisliceoutliers shells.mif spred.mif -mask mask.mif sliceweights.txt -force' + ort)

# slice-to-volume registration
for k in range(s2viter):
    # register template to slices
    with open('motion.txt', 'w') as f:
        prog = app.progressBar('Registering recon to data slices', dims[3]*dims[2]//mb)
        for v in range(dims[3]):
            volmotion = ''
            if k == 0:
                run.command('mrconvert -coord 3 ' + str(v) + ' pred.mif template.mif -force')
            run.command('mrconvert -coord 3 ' + str(v) + ' shells.mif target.mif -force')
            for s in range(dims[2]//mb):
                run.command('maskslice -mb ' + str(mb) + ' mask.mif ' + str(s) + ' slicemask.mif -force')
                if k > 0:
                    run.command('mrconvert -coord 3 ' + str(v*dims[2] + s) + ' pred.mif template.mif -force')
                run.command('mrreg_lin template.mif target.mif -nonsymmetric -mask2 slicemask.mif' +
                        ' -type rigid -affine_init ' + ('T-'+str(v)+'-'+str(s)+'.txt' if k>0 else 'T-'+str(v)+'.txt') +
                        ' -affine_scale 1.0 -affine T-'+str(v)+'-'+str(s)+'.txt -affine_niter 3 -force')
                run.command('transformcalc T-'+str(v)+'-'+str(s)+'.txt decompose trafo.txt -force')
                with open('trafo.txt') as f2:
                    L = f2.readlines()
                tra = L[4].strip().split(':')[1].strip()    # translation
                rot = L[2].strip().split(':')[1].strip()    # rotation
                volmotion += tra + ' ' + rot + '\n'
                prog.increment()
            for m in range(mb):
                f.write(volmotion)
        prog.done()
    # update template
    run.command('dwirecon shells.mif ' + recon_option + ' recon-'+str(v2viter+k+1)+'.mif -motion motion.txt' +
                ' -weights sliceweights.txt -init recon-'+str(v2viter+k)+'.mif -rpred pred.mif' +
                ' -spred spred.mif' + (' -tpred result-s.mif' if k+1==s2viter else '') + ' -force' + nthr)
    run.command('dwisliceoutliers shells.mif spred.mif -mask mask.mif sliceweights.txt -force' + ort)


#   __________ Copy outputs __________

run.command('mrconvert result-v.mif ' + path.fromUser(outvi, True) + (' -force' if app.force else ''))
run.command('mrconvert recon-'+str(v2viter)+'.mif ' + path.fromUser(outvc, True) + (' -force' if app.force else ''))
if s2viter > 0:
    run.command('mrconvert result-s.mif ' + path.fromUser(outsi, True) + (' -force' if app.force else ''))
    run.command('mrconvert recon-'+str(v2viter+s2viter)+'.mif ' + path.fromUser(outsc, True) + (' -force' if app.force else ''))

app.complete()




