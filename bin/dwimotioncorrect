#!/usr/bin/env python

#   MOTION CORRECTION FOR DWI VOLUME SERIES
#
#   This script performs volume-to-series and slice-to-series registration
#   of diffusion-weighted images for motion correction in the brain.
#
#   Author:  Daan Christiaens
#            King's College London
#            daan.christiaens@kcl.ac.uk
#

#   __________ Initialisation __________

# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys
#lib_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile(inspect.currentframe()))[0], os.pardir, 'lib')))
lib_folder = os.path.realpath(os.path.abspath('/home/dc16/dev/mrtrix3/lib'))
if not os.path.isdir(lib_folder):
    sys.stderr.write('Unable to locate MRtrix3 Python libraries')
    sys.exit(1)
sys.path.insert(0, lib_folder)

from mrtrix3 import app, fsl, image, path, run


app.init('Daan Christiaens (daan.christiaens@kcl.ac.uk)',
         'Perform motion correction for a DWI volume series')

app.cmdline.add_argument('input',  help='The input image series to be corrected')
app.cmdline.add_argument('output', help='The output corrected image series')

options = app.cmdline.add_argument_group('Options for the dwimotioncorrect script')
options.add_argument('-mask', help='Manually provide a mask image for motion correction')
options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
options.add_argument('-niter', help='Number of epochs (default = 3)')
options.add_argument('-shell', help='Shell to be processed (default = 0)')
options.add_argument('-lmax', help='SH basis order (default = 0)')
app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )
app.parse()


grad_import_option = ''
if app.args.grad:
    grad_import_option = ' -grad ' + path.fromUser(app.args.grad, True)
elif app.args.fslgrad:
    grad_import_option = ' -fslgrad ' + path.fromUser(app.args.fslgrad[0], True) + ' ' + path.fromUser(app.args.fslgrad[1], True)


app.checkOutputPath(app.args.output)

app.makeTempDir()

run.command('mrconvert ' + path.fromUser(app.args.input, True) + ' ' + path.toTemp('in.mif', True) + grad_import_option)
if app.args.mask:
    run.command('mrconvert ' + path.fromUser(app.args.mask, True) + ' ' + path.toTemp('mask.mif', True))

app.gotoTempDir()


# Make sure it's actually a DWI that's been passed
dwi_sizes = image.headerField('in.mif', 'size').split()
if len(dwi_sizes) != 4:
    app.error('Input image must be a 4D image')
DW_scheme = image.headerField('in.mif', 'dwgrad').split('\n')
if len(DW_scheme) != int(dwi_sizes[3]):
    app.error('Input image does not contain valid DW gradient scheme')


# Generate a brain mask if required, or check the mask if provided
if app.args.mask:
    mask_sizes = image.headerField('mask.mif', 'size').split()
    if not mask_sizes[:3] == dwi_sizes[:3]:
      app.error('Provided mask image does not match input DWI')
else:
    run.command('dwi2mask in.mif mask.mif')


# Set no. iterations
niter = 3
if app.args.niter:
    niter = int(app.args.niter)

# Set shell
shell = 0
if app.args.shell:
    shell = int(app.args.shell)

# Set lmax
lmax = 0
if app.args.lmax:
    lmax = int(app.args.lmax)
if shell==0 and lmax>0:
    app.error('Option -lmax ' + str(lmax) + ' incompatible with b=0 shell.')


#   __________ Motion correction __________

# select shell
run.command('dwiextract -shell ' + str(shell) + ' in.mif shell.mif')
dims = map(int, image.headerField('shell.mif', 'size').split())
if dims[3] < (lmax+1)*(lmax+2)//2:
    app.error('Option -lmax ' + str(lmax) + ' incompatible with n=' +str(dims[3])+ ' volumes in b=' + str(shell) + ' shell.')
run.command('mrinfo shell.mif -export_grad_mrtrix grad.txt')

# initial template
if shell:
    run.command('amp2sh -lmax ' + str(lmax) + ' shell.mif recon-0.mif')
else:
    run.command('mrmath -axis 3 shell.mif mean b0init.mif')
    run.command('mrconvert -axes 0,1,2,-1 b0init.mif template.mif')
    run.command('mrcalc template.mif 0.282095 -divide recon-0.mif')
sh2amp('sh2amp -gradient recon-0.mif grad.txt pred.mif')

for k in range(niter):
    # register template to volumes
    f = open('motion.txt', 'w')
    for v in range(dims[3]):
        run.command('mrconvert -coord 3 ' + str(v) + ' pred.mif template.mif -force')
        run.command('mrconvert -coord 3 ' + str(v) + ' shell.mif target.mif -force')
        run.command('mrreg_lin template.mif target.mif -nonsymmetric -mask2 mask.mif' +
                    ' -type rigid ' + ('-affine_init T-'+str(v)+'.txt' if k>0 else '') +
                    ' -affine_scale ' + str(0.3 + 0.7*k/(niter-1.0)) + ' -affine T-'+str(v)+'.txt -force')
        run.command('transformcalc T-'+str(v)+'.txt decompose trafo.txt -force')
        f2 = open('trafo.txt')
        L = f2.readlines()
        f2.close()
        tra = L[4].strip().split(':')[1].strip()    # translation
        rot = L[2].strip().split(':')[1].strip()    # rotation
        f.write(tra + ' ' + rot + '\n')
    f.close()
    # update template
    run.command('dwirecon shell.mif recon-'+str(k+1)+'.mif -lmax '+str(lmax)+' -motion motion.txt -rpred pred.mif -force')

run.command('mrconvert recon-'+str(niter)+'.mif result.mif')


# Copy result to output path
run.command('mrconvert result.mif ' + path.fromUser(app.args.output, True) + (' -force' if app.force else ''))

app.complete()

